
# `Rust`基础

---

*Rust is a system's prgramming Language that runs blazingly fast, prevents segfaults, and guarantees thread safety*

* `Rust`语言是一门系统编程语言，它有三大特点：**运行快**、**防止段错误**、**保证线程安全**。

* **系统级编程**是相对于应用级编程而言。一般来说，系统编程意味着更底层的位置，它更接近于硬件层次，并为上层的应用软件提供支持

* 系统级编程语言一般具有以下特点：
  * 可以在资源非常受限的环境下执行；
  * 运行时开销很小，非常高效；
  * 很小的运行库，甚至于没有；
  * 可以允许直接的内存操作。

* 目前，`C`和`C++`应该是业界最流行的系统编程语言。`Rust`的定位于他们类似，但是增加了安全性。`C`和`C++`都是编译型语言，无须规模庞大的运行时（`runtime`）支持，也没有自动内存回收（`Garbage Collection`）机制。

## 1.1 版本和发布策略

* `Rust`编程语言是开源的，编译器的源码位于[https//github.com/rust-lang/rust](https//github.com/rust-lang/rust)项目中，语言设计和相关讨论位于[https//github.com/rust-lang/rfcs](https//github.com/rust-lang/rfcs)项目中。
* `Rust`项目是完全由开源社区管理和驱动的。
* `Rust`编译器的版本号采用了“语义化版本号”（`Semantic Versioning`）规划。在这个规则之下，版本格式为：主版本号.次版本号.修订号。版本号递增规则如下：
  * 主版本号：当你做了不兼容的`API`修改
  * 次版本号：当你做了向下兼容的功能性新增
  * 修订号：当你做了向下兼容的问题修正

* `Rust`的第一个正式版本号是1.0，是2015年5月发布的。从那以后，只要版本没有出现大规模的不兼容的升级，大版本号就一直维持在“1”，而次版本号会逐步升级。`Rust`一般以6个星期更新一个正式版本的速度进行迭代。

* 为了兼顾更新速度以及稳定性，`Rust`使用了多渠道发布的策略：
  * `nightly`版本
    * `nightly`版本是每天在主板本上自动创建出来的版本，这个版本上的功能最多，这个版本上的功能最多，更新最快，但是某些功能存在问题的可能性也更大。因为新功能会首先在这个版本上开启，供用户试用。
    * 在`nightly`版本中使用试验性质的功能。必须手动开启`feature gate`。也就是说要在当前项目的入口文件中加入一条`#![feature(···name···)]`语句。否则是编译不过的。等到这个功能最终被稳定了，再用新版编译器编译的时候，它会警告你这个`feature gate`现在是多余的了，可以去掉了。
  * `beta`版本
    * `beta`版本是每隔一段时间，将一些在`nightly`版本中验证过的功能开放给用户试用。它可以被看作`stable`版本的“预发布”版本。
  * `stable`版本
    * `stable`版本则是正式版，它每隔6个星期发布一个新版本，一些实验性质的新功能在此版本上无法使用。它也是最稳定、最可靠的版本。`stable`版本是保证向前兼容的。

* `Rust`语言相对重大的设计，必须经过`RFC`(`Request For Comments`)设计步奏。这个步骤主要用于讨论如何“设计”语言。这个项目存在于[https://github.com/rust-lang/rfcs](https://github.com/rust-lang/rfcs)。所有大功能必须先写好设计文档，讲清楚设计的目标、实现方式、优缺点等，让整个社区参与讨论，然后由“核心组”（`Core Teeam`）的成员参与定夺是否接受这个设计。

* 强烈建议各位读者多读一下`RFC`文档，许多深层的设计思想问题可以在这个项目中找打答案。
* 在`Rust`社区，我们不仅可以看到最终的设计结果，还能看到每一步设计的过程，对我们来说非常有教育意义。

* `Rust`语言每个相对复杂一点的新功能，都要经历如下步奏才算真正稳定可用：

    ```flow
        st=>start: RFC
        op=>operation: Nightly
        op1=>operation: Beta
        e=>end: Stable
        st(right)->op(right)->op1(right)->e
    ```

  * 先编写一份`RFC`，其中包括这个功能的目的、详细设计方案、优缺点探讨等。如果这个`RFC`被接受了，下一步就是在编译器中实现这个功能，在`nightly`版本中开启。经过几个星期甚至几个月的试用之后，根据反馈结果来决定撤销、修改或者接受这个功能。如果表现不错，它就会进入`beta`版本，继续过几个星期后，如果确实没发现什么问题，最终会进入`stable`版本。至此，这个功能才会被官方正式定为“稳定的”功能，在后续版本中要确保兼容性的。

* 在2017年下半年，`Rust`设计组又提出了一个基于`epoch`的演进策略（后来也被称为`edition`）。它要解决的问题是，如何让`Rust`更平稳地进化。比如，有时某些新功能确实需要一定程序上破坏兼容性。为了最大化地减少这些变动给用户带来的影响，`Rust`设计组又设计了一个所谓的`edition`的方案。简单来说就是让`Rust`的兼容性保证是一个有时限的长度，而不是永久

* 举个`edition`方案例子。假设我们要添加一个功能，比如增加一个关键字。这件事情肯定是不兼容的改变，因为用户写的代码中很可能包含用这个关键字命名的变量、函数、类型等，直接把这个单词改成关键字会直接导致这些遗留代码出现编译错误。那怎么办呢？首先会在下一个`edition`中做出警告，提示用户这个单词已经不适合作为变量名了，请用户修改。但是这个阶段代码依然编译通过。然后到再下一个`edition`的时候，这个警告就会变成真正的编译错误，此时这个关键字就可以真正启用了。先编译警告，再编译错误，这个过程可能会持续好几年，所以`Rust`的稳定性还是基本上有保证的。
* 如果要求维持百分之百的兼容性，`Rust`语言就很难再继续进化了。如果让极少一部分受影响的遗留代码，完全锁死整个语言的进步空间，对于那些特别需要某些新功能的用户来说也是不公平的。通过这个缓慢过度的策略，基本可以让所有`Rust`的使用者平滑、无痛地过度到新版本。

## 1.2 安装开发环境

* `Rust`编译器的下载和安装方法在官网上有文档说明，点击官网上的Install链接可以查看。
* `Rust`官方已经提供了预编译好的编译器供我们下载。支持Windows平台、Linux平台以及Mac平台。
* 一般我们不单独下载`Rust`的编译器，而是使用一个叫`rustup`的工具安装`Rust`相关的一整套工具链，包括编译器、标准库、cargo等。
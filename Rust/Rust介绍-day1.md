<!--
 * @Author: herhan
 * @Date: 2020-06-09 21:43:29
 * @LastEditTime: 2020-06-26 10:37:54
 * @LastEditors: herhan
 * @Description: In User Settings Edit
 * @FilePath: \github\notebook\Rust\Rust介绍-day1.md
--> 

# `Rust` 介绍

---
<!-- TOC -->

- [`Rust` 介绍](#rust-介绍)
  - [1.安全](#1安全)
  - [2.并发](#2并发)
  - [3.实用](#3实用)

<!-- /TOC -->


*Rust is a system's prgramming Language that runs blazingly fast, prevents segfaults, and guarantees thread safety*

## 1.安全

* `Rust`最重要的特点就是可以提供内存安全保证，而且没有额外的性能损失。

* 在传统的系统级编程语言（`C/C++`）的开发过程中，经常出现因各种内存错误引起的崩溃或`bug`。比如空指针、野指针、内存泄漏、内存越界、段错误、数据竞争、迭代器失效等，血泪斑斑，数不胜数。这些问题不仅在教科书中被无数次提起，而且在实践中也极其常见。因此，各种高手辛苦地总结了大量的编程经验，许多代码检查和调试工具被开发出来，各种代码开发流程和规范被指定出来，无数人呕心沥血就是为了系统性地防止各类`bug`的出现。

* 鉴于手动内存管理非常容易出问题，因此先辈们发明了一种自动垃圾回收的机制（`Garbage Collection`），故而程序员在绝大多数情况下不用再操心内存释放的问题。新发明的绝大多数编程语言都使用了基与各种高级算法的自动垃圾回收机制，因为它确实方便，解放了程序员的大脑，使大家能更专注于业务逻辑的部分。但是到目前为止，不管使用哪种算法的`GC`系统，在性能上都要付出比较大的代价。要么需要较大的运行时占用较大内存，要么需要暂停整个程序，要么具备不确定性的时延。当然，在现实的许多业务场景中，这点开销是微不足道的，因此问题不大。可是如果在性能敏感的领域，这是完全不可接受的。

* `Rust`对自己的定位是接近芯片硬件的系统级编程语言，因此，它不可能选择使用自动垃圾回收的机制来解决问题。事实证明，要想解决内存安全问题，小修小补是不够的，必须搞清楚导致内存错误的根本原因，从源头上解决。Rust就是为此而生的。Rust语言是可以保证内存安全的系统级编程语言。

## 2.并发

* `Rust`非常好地支持了并发编程。更重要的是，在强大的内存安全特性的支持下，Rust一举解决了并发条件下的数据竞争（`Data Race`）问题。它从编译阶段就将数据竞争解决在了萌芽状态，保障了线程安全。
* `Rust`在并发方面还具有相当不错的可扩展性。所有跟线程安全相关的特性，都不是在编译器中写死的。用户可以用库的形式实现各种高效且安全的并发编程模型，进而充分利用多核时代的硬件性能。

## 3.实用

* `Rust`并不只是实验室中的眼界型产品，它的目标是解决目前软件行业中实实在在的各种问题。
* `Rust`编译器的后端是基于著名的`LLVM`完成机器码生成和优化的，它只需要一个非常小巧的运行时即可工作，执行效率上可与`C`语言相媲美，具备很好的跨拼台特性。
* `Rust`摈弃了手动内存管理带来的各种不安全的弊端，同时也避免了自动垃圾回收带来的效率损失和不可控性。在绝大部分情况下，保持了“无额外性能损失”的抽象能力。
* `Rust`具备比较强大的类型系统，借鉴了许多现代编程语言的历史经验，包含了众多方便的语法特性。其中包含代数类型系统、模式匹配、闭包、生成器、类型推断、泛型、与`C`库`ABI`兼容、宏、模块管理机制、内置开源库发布和管理机制、支持多种编程范式等。它吸收了许多其他语言中优秀的抽象能力，海纳百川，兼容并蓄。在不影响安全和效率的情况下，拥有不俗的抽象表达力。
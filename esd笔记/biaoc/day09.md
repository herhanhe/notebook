---
title: biaoc Day09
tags: esd笔记
notebook: biaoc
---
## biaoc Day09

* 数组可以作为形式参数使用
	* 通常使用数组名称作为实际参数和数组形式参数配合使用
	* 真正的形式参数并不是数组，而是一个可以当作数组使用的变量
	* 数组形式参数里包含的所有存储区都不是被调用函数提供的
	* 通过数组形式参数可以让被调用函数使用其他函数提供的存储区
	* 调用函数和被调用函数都可以使用数组形式参数里的存储区，所以可以利用数组形式参数实现双向数据传递。这种参数叫输入输出参数。
	* 声明数组形式参数的时候可以省略数组里包含的存储区个数
	* 这个时候需要使用另外的整数类型形式参数表示数组里的存储区个数

* C语言中允许函数的形式参数的个数不确定,这种参数叫做变长参数
	* 变长参数不能在编写函数的时候命名，在被调用函数里需要使用特殊的方法才能获得变长参数里的内容

* 如果编译器先遇到函数调用语句就猜测被调用函数的格式。猜测结果里认为函数有一个整数类型存储区用来存放返回值，函数可以提供任意多个任意类型的形式参数。这个猜测结果叫做函数的隐式声明。
	* 隐式声明中形式参数的类型只能是整数类型或双精度浮点类型
	* 如果隐式声明的格式和函数真正的格式不一致就会编译出错
* 函数大括号前面的部分叫函数声明，可以把函数声明单独写成一条语句放在文件开头，这个时候可以省略形式参数名称;这样做叫做函数的显示声明
	* 显示声明可以避免隐式声明
	* 除了主函数以外的所有函数都应该进行显示声明

* exit标准函数可以立刻结束程序的执行
	* 为了使用这个标准函数需要包含stdlib.h头文件
	* 使用这个函数的时候需要提供一个整数类型的实际参数，这个实际参数的作用和主函数返回值的作用一致。
---
* C语言里函数可以调用自己,这种函数叫递归函数
    * 如果一个问题可以分解成几个小问题，其中至少一个小问题和原来的大问题在本质上一样，这种问题就适合采用递归方式解决。
    * 递归函数编写步骤：
    * 1 编写语句描述问题的分解方式（假设递归函数已经编写完成）
	* 2.在函数开头编写分支处理不可分解的情况，这个分支必须保证函数可以结束

* 用递归函数解决问题的方法叫递归
* 用循环解决类似问题的方法叫递推
---
* 程序中可以使用某个变量的所有语句叫做这个变量的作用域
* 声明在函数里面的变量叫局部变量，局部变量的作用域是函数里面的所有语句;声明在所有函数外边的变量叫全局变量，全局变量的作用域是程序中的所有语句

    * 没有初始化的全局变量会自动被初始化成`0`
	* 全局变量和局部变量可以重名，这个时候程序中的语句优先选择局部变量
	* 如果全局变量和局部变量都能解决问题就应该优先选择局部变量

* 存储区的使用不受作用域限制(可以跨函数使用存储区),存储区的使用受到生命周期的限制
	* 生命周期是一段时间，存储区只能在某个时间范围内才可以使用
	* 全局变量的生命周期就是整个程序的执行时间
	* 局部变量生命周期是函数某一次执行的时间范围
	* 如果一个函数多次执行则每次局部变量对应的存储区都可能不同

* 可以使用`static`关键字声明变量，这种变量叫做静态变量
	* 静态变量的生命周期都是整个程序的执行时间
	* 如果函数多次运行则每次静态局部变量对应的存储区都是同一个
	* 函数不运行的时候静态局部变量的存储区也是可以使用的
	* 没有初始化的静态变量自动被初始化成`0`
	* 静态变量的初始化只在程序开始的时候执行一次
	* 静态全局变量的作用域只包含声明它的那个文件里的所有语句
---
* 指针变量用来记录地址数据
	* 指针变量的用途就是用来找另外一个变量的
	* 只有记录了有效地址的指针才能使用
	* 只要在指针变量名称前使用`*`操作符就可以表示捆绑存储区

* 指针也分类型，不同类型的指针适合与不同存储区捆绑
    * 可以在一条语句里声明多个同类型的指针，必须在每个指针变量名称前单独加`*`

* 所有没捆绑过的指针分成两类：
	* 1.空指针记录固定地址（空地址，用`NULL`表示，这个地址的数值就是`0`）
	* 2.除了空指针以外没有捆绑过的指针都叫野指针

* 程序中禁止出现野指针
* 指针变量必须初始化
* 指针初始化的时候`*`没有参与赋值过程
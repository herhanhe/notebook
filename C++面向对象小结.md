---
title: C++面向对象小结
tags: 学习
notebook: C++ 
---
# C++面向对象小结

## 1.类和对象的区别
* 类是抽象的，对象是具体的，所以类不占内存，而对象占内存。
* 总之类是对象的抽象，而对象是类的具体事例。
* 假如类是水果，那么对象就是香蕉。

## 2.面向对象的三大特点
* 面向对象三大特点是封装、继承、多态。

## 3.类的3种访问限定符
* （1）`public`（公共的）
* （2）`private`（私有的）
* （3）`protected`（受保护的）
* 它们的特点如下：
  * （1）`public`成员可从类外部直接访问，`private/protected`成员不能从类的外部直接访问。
  * （2）每个限定符在类体中可使用多次，它的作用域是从该限定符出现开始到下一个限定符之前或类体结束前。
  * （3）类体中如果没有定义限定符，就默认为私有的，而`struct`如果没有定义限定符，就默认为公有的。
  * （4）类的访问限定符体现了面向对象的封装性。

## 4.类的作用域
* （1）每个类都定义了自己的作用域，类的成员（成员函数、成员变量）都在类的这个作用域内，成员函数内可任意访问成员变量和其他成员函数。
* （2）对象可以通过“`.`”直接访问公有成员，指向对象的指针通过“`->`”也可以直接访问对象的公有成员。
* （3）在类体外定义成员，需要使用“`::`”作用域解析符指明成员属于哪个类域。

## 5.隐含的this指针
* （1）每个成员函数都有一个指针形参，它的名字是固定的，称为`this`指针，`this`指针是隐式的（构造函数比较特殊，没有这个隐含`this`形参）。
* （2）编译器会对成员函数进行处理，在对象调用成员函数时，对象地址作为实参传递给成员函数的第一个形参`this`指针。
* （3）`this`指针是成员函数隐含的指针形参，是编译器自己处理的，我们不能在成员函数的形参种添加`this`指针的参数定义，也不能在调用时显示传递对象的地址给`this`指针。

## 6.类的6个默认成员函数
* （1）构造函数
* （2）拷贝构造函数
* （3）赋值操作符重载
* （4）析构函数
* （5）取地址操作符重载
* （6）`const`修饰的取地址操作符重载

## 7.构造函数的特征
* （1）函数名与类名相同。
* （2）无返回值。
* （3）对象构造时系统自动调用对应的构造函数。
* （4）构造函数可以重载。
* （5）构造函数可以在类外定义，也可以在类内定义。
* （6）如果类定义中没有给出构造函数，`C++`编译器就会自动产生一个默认的构造函数，但是只要我们定义了一个构造函数，系统就不会自动生成默认的构造函数。
* （7）无参的构造函数和全默认值的构造函数都认为是默认构造函数，并且默认的构造函数只能有一个。
```c++
    class Date
    {
        public:
            Date() //无参构造函数
            {}
            Date(int year=1990, int month = 1, int day = 1) //全默认值的构造函数
                :_year(year)
                , _day(day)
                , _month(month)
            {}
        protected:
            int _year;
            int _month;
            int _day;
    };
```
## 8.拷贝构造函数
* （1）拷贝构造函数其实是一个构造函数的重载。
* （2）拷贝构造函数的参数必须使用引用传参，使用传参方式会引发无穷递归调用。
* （3）若未显式定义，系统会使用默认的拷贝构造函数。默认的拷贝构造函数会依次对拷贝类成员进行初始化。

## 9.析构函数
* （1）析构函数在类名前加上字符`~`。
* （2）析构函数无参数、无返回值。
* （3）一个类只有一个析构函数，若未显式定义，系统会自动生成默认的析构函数。
* （4）对象生命周期结束时，`C++`编译系统会自动调用析构函数。
* （5）析构函数体内并不是删除对象，而是做一些清理工作。
```C++
    class Array
    {
        public:
            Array(int size)
            {
                _ptr = (int*)malloc(sizeof(int)*size);
            }
            ~Array()
            {
                if (_ptr)
                {
                    free(_ptr);
                    _ptr = NULL;
                }
            }
        protected:
            int* _ptr;
    };
```
## 10.类成员变量的两种初始化方式
* （1）初始化列表。
* （2）析构函数体内进行赋值。
* 初始化列表以一个冒号开始，接着以一个逗号分隔数据列表，每个数据成员都放在一个括号中进行初始化。尽量使用初始化列表进行初始化，因为它更高效。
  
## 11.友元函数
* 在`C++`中，友元函数允许在类外访问该类中的任何成员函数，就像成员函数一样，友元函数用关键字`friend`说明。
* （1）友元函数不是类的成员函数。
* （2）友元函数可以通过对象访问所有成员，私有和保护成员也一样。
```C++
    class Date
    {
            friend void Display(const Date& d);
        public:
            Date(int year = 1990, int month = 1, int day = 22)
                :_year(year)
                , _month(month)
                , _day(day)
            {}
        private:
            int _year;
            int _month;
            int _day;
    };
    void Display(const Date& d)
    {
        cout << "year=" << d._year << endl;
        cout << "month=" << d._month << endl;
        cout << "day=" << d._day << endl;
    }
    int main ()
    {
        Date d1;
        Display(d1);
        return 0;
    }
```
* *注：友元函数在一定程度上破坏了`C++`的封装，不宜多用，在恰当的地方使用即可。*

## 12.类的静态成员函数
* （1）类里面用`static`修饰的成员，称为静态成员。
* （2）类的静态成员是该类型的所有对象所共享的。
```C++
    class Date
    {
        public:
            Date()
            {
                cout <<"Date ()" << endl;
                ++ sCount;
            }
            void Display()
            {
                cout << "year:" << _year << endl;
                cout << "month:" << _month << endl;
                cout << "day:" << _day << endl;
            }
            //静态成员函数
            static void PrintCount()
            {
                cout <<"Date count" << sCount << endl;
            }
        private:
            static int sCount;  //静态成员变量，统计创建时间个数
    }；
    //定义并初始化静态成员变量
    int Date::sCount = 0;
    void Test ()
    {
        Date d1,d2;
        //访问静态成员
        Date::PrintCount();
    }
```
* 静态成员函数没有隐含`this`指针参数，所有可以使用类型`::`作用域访问符直接调用静态成员变量。
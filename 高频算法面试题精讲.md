---
title: 高频算法面试题精讲
tags: 学习
notebook: 算法
---
# 高频算法面试题精讲


[课程参考代码](https://github.com/chlxydl/Algorithm_Class_Problem_Sample_Code)

## 1. 开始热身吧！	
### 1.1 刷题秘籍 
* 为什么要学习数据与算法？
* 如何系统学习数据结构与算法？（含推荐书单）
* 如何通过力扣（Leetcode）高效备战算法面试？
#### 1.1.1 如何规划刷题过程
* 为什么选择leetcode
    * 算法题可以快速的判断候选人的代码和思维能力
    * 面试题的集中地，认可度高
* AC(Accept)的四个级别
    * 勉强给出正确的解法
    * 快速给出正确的解法，完美应对所有的测试数据，包括可能的边角数据
    * 快速给出最优的正确解法
    * 快速给出最优的正确解法，代码分格非常优美，变量名含义清晰，过程清楚明白，有一些简单的注释
#### 1.1.2 如何规划刷题过程
* 阶段策略
    * 刚接触算法题目：分专题掌握知识点 （easy 60%  medium 30%）
    * 已经熟悉相关算法：巩固知识脉络和手  （easy 100% medium 40%）（easy 5min medium  20min）
    * 对基本算法饿题目已经非常熟练：接触高级的算法和数据结构，提成应试能力 （参加，周测）
#### 1.1.3 小技巧和常见误区
* 程序的运行速度和时间复杂度：不用执着于优化常熟
* 关于空间复杂度：没有特殊要求不用苛求
* 关于语言选择：建议C**，用python可能有坑
* 如何确定最优解法：问数据范围
#### 1.1.4 推荐书单
* 面向入门级：《算法图解》
* 经典书籍：《算法导论》 （Introduction to Algorithms）
* 不同编程语言书籍：《数据结构与算法分析：C语言描述》《数据结构与算法：python语言描述》
* 面向刷题和工作：《剑指offer》

![1](https://img.vim-cn.com/14/595018614d3ca31bf632b6dbefefcb323f874a.png
)

### 1.2 算法复杂度
* 算法复杂度
* 如何快速计算时间复杂度
#### 1.2.1 什么是算法复杂度？
* 时间复杂度
* 空间复杂度
#### 1.2.2 时间复杂度
* 时间复杂度
    * 估算计算次数
    * 用变量代替计算次数
	```python
        def func():
            n = 10
            for i in range(n):
                for j in range(i,n):
                    a = 1

	```
	![2](https://img.vim-cn.com/dc/1d84b4aae2232d62a925d874b3a4cfd33e3b68.png)
    * 结果只保存最高次的项，并且不保留次数
* 复杂度常数
    * 时间复杂度仍为$o(n^2)$
    * $o(n^2)$ VS $o(n^3)$ ?   前者更优
	```python
        def func():
            n = 10
            for i in range(n):
                for j in range(i,n):
                    a = 1
                    a = 2

	```
	![3](https://img.vim-cn.com/a9/c49c7c2f4526d09d1ac03158f595e32915bd1e.png)
    * 系数、非最高次项均可视为常数
* 如果你的程序跑得慢
    * 是否时间复杂度不对
    * 是否常数太大
    * leedcode给的时间并不具有绝对的指导意义（可能是由于好的库优化,好的常数）
#### 1.2.3 算法复杂度示例
* 常数复杂度$O(1)$
	```python
		def func():
		    a = 1
	```
* 线性复杂度$O(N)$
	```python
		def func():
		    n = 10
		    for i in range(n):
		        a = 1
	```
* 多项式复杂度$O(n^2)$
	```python
		def func():
		    n = 10
		    for i in range(n):
			    for j in range(i,n):
					a = 1
	```
* 指数复杂度$O(2^n)$
	```python
		def func(n):
		    if n <= 1: return n
		    return func(n - 1)*func(n - 1)
	```
* 对数复杂度$O(log(N))$
	```python
		def func(n):
		    if n <= 1: return n
		    return func(n//2)*1
	```
* 渐进复杂度$O(N)$
	```python
		def func(n):
		    if n <= 1: return
		    mid = n // 2
		    for i in range(mid*1,n):
		        a = 1
		        func(mid)
	```
	$f(n)=n/2*n/4*n/8*...<= n$
* 均摊复杂度$O(N)$
    * 如果有n次操作，时间复杂度是多少？
	```python
		a = []
		def func(x):
		    if x == 0:
			    a.push(x)
		    else:
			    while a.size() > 0:
				    a.pop()
	```
    * $x = 0$,单次时间复杂度为$O(1)$
    * $x != 0$,单次时间复杂度为$O(N)$

    * 总的`pop`次数不会超过全部$x = 0$的次数，所以总体复杂度为$O(N)$
## 2. 数据结构篇
### 2.1 数组
#### 2.1.1[理论讲解]数组
* 定义
    * 一串连续的数据  `[1,2,3],['a','b','c'],[1,'a',0]`
    * 一维数组和多维数组
	```
                                [[1.,1.,1.,1.,1.],
                                 [1.,1.,1.,1.,1.],
        [1.,1.,1.,1.,1.]         [1.,1.,1.,1.,1.],
                                 [1.,1.,1.,1.,1.],
                                 [1.,1.,1.,1.,1.]]
	```
* 操作
    * 遍历
	```python
		for i in range(n):
		    for j in range(m):
		        array[i][j] = xxx
	```
    * 索引
* 动态数组的实现
    * 需要的操作：`push_back,pop_back,size,index`
    * 难点：不可能直接开无限内存

    * 假定数组长度为10
    * 1）数组长度增加1
    * **2）数组长度扩大一倍** 
      * $n*n/2*n/4*n/8*... < 2n$ 时间复杂度为$O(n)$

    * class mlist
    * 成员：`mlist.size=0, mlist.allsize=0,mlist.a=[]` 
    * 方法： `push_back`: 检查`size`是否满，如果满，`allsize`倍增，然后插入一个元素`pop_back`: 删除最后元素，`size-1``index`:返回a的相应位置元素`size`: 返回`size` 
#### 2.2.2 [面试题]找数组左边的重复数
> 题目：给定一个数组，以从左往右的顺序，返回每个数第一次出现的下标，如果不存在则输出-1<br/>
> 例子：<br/>
> 输入：[1,3,1,2,1]<br/>
> 输出：[-1,-1,0,-1,0]<br/>
* 边界条件

	* 输入`[ ]`，返回`[ ]`。
* 暴力解法

	![4](https://img.vim-cn.com/09/7bc84b22bfa78c32c8d80c38d8dd49baa7e772.png)
    * 1.枚举数组中所有的数
    * 2.对于每个数，枚举其前面的所有数
    * 3.如果存在一个相同，则返回下标，否则返回`-1`
* $O(N)$解法

    * 是否存在更优解法？解决冗余!
    * 直接标记每个数是否存在
  
	![5](https://img.vim-cn.com/f0/d5b310170566118e03d8f2850146cf971371dc.png)
    * 1.新建一个`dict`
    * 2.枚举每个数
    * 3.如果`dict`中存在该数，返回下标
    * 4.否则将其插入到`dict`中返回`-1`
* 思考题
    * 判断当前位置的数第几次出现？
    * 判断当前位置的数上一次出现是什么时候？
    * 求当前为和上一次出现位置中间所有数的和？（`sum`辅助数组）
#### 2.2.3 [面试题] （Leetcode）238 求所有数除了自己的乘积
> 题目：给定长度为`n`的整数数组`nums`,其中n>1,返回输出数组`output`,其中`output[i]`等于`nums`中除`nums[i]`之外其余各元素的成绩<br/>
> <font color=#ff1c3e>限制：不允许使用除法，空间复杂度$O(N)$</font><br/>
> 例子：<br/>
> 输入：[1，2，3，4]<br/>
> 输出：[24，12，8，6]<br/>
* 边界条件
    * $n>1$,无边界条件
* 除法解法
    * 1.求所有数的乘积
    * 2.对于每个数，结果为乘积除以当前数
    * 3.注意`0`的请况
* 不用除法解法
    * 1.换一种角度，乘法满足结合律$a*b*(c)*d*e =>[a*b]*[d*e]$
    * 2.（暴力解法）对于每个数，算其左边和右边所有数乘积，$O(N^2)$
    * 3.思考冗余
    * 4.维护两个乘积数组，一个左积，一个右积，$O(N)$
	![6](https://img.vim-cn.com/ce/5d4cef239a5cf84129734a7bbdcef34dddb0ff.png)
* 常数空间（优化空间）
	* 注意：一般的，返回数组不算空间
    * 1.我们需要省两个数组的空间
    * 2.省结果数组
    * 3.省右积数组<br/>
	![7](https://img.vim-cn.com/90/4fdaf8c47dedb95e8dd49cd77dad57ec0e7e65.png)<br/>
	![8](https://img.vim-cn.com/92/af2d2e578bf8ba58b06a447c415d0bb421c109.png)<br/>
	![9](https://img.vim-cn.com/3c/d88d2800b58d9f7906f5c71d6727a3586a9fdf.png)<br/>
	![10](https://img.vim-cn.com/97/03e68149d4998f11898cfe77f0b34393cb09a4.png)<br/>
	![11](https://img.vim-cn.com/bd/0d1d5c0e8ce3fbda4d7dd529cf6fe71f56cd87.png)<br/>
	![12](https://img.vim-cn.com/86/06abe35e94428cd4f417ca8c313a87a6f9f712.png)<br/>
	![13](https://img.vim-cn.com/34/6fea8bd35e463ad0a00f3b91d7d322888e8a63.png)<br/>
	![14](https://img.vim-cn.com/c1/2575b561af5ae9debce0347fd69a45a9b8f2d6.png)<br/>

* 思路整理：
    * 1.一次循环预处理出左积数组<br/>
	![15](https://ws2.sinaimg.cn/large/006Xmmmggy1g554pol2nxj309e07rt97.jpg)<br/>
    * 2.用一个变量`last_product`来表示右积数组的当前值<br/>
	![16](https://ws2.sinaimg.cn/large/006Xmmmggy1g554qcixlnj309h07o0t9.jpg)<br/>
    * 3.逆序循环，维护右积数组当前值和结果<br/>
	![17](https://img.vim-cn.com/8c/6fdfc2f0c5a54ecc7736dce563ffff394f0f70.png)<br/>
* 思考题
    * 求数组中除了自己所有数的方差。
    	* $(X-Xmean)^2 => X^2-2XXmean*Xmean^2$ 
    * 有`n`个询问，每个询问给出数组下标范围`[i,j]`,要求返回`[i,j]`之间所有数的乘积。
        * 1.前`i`个数的乘积（不包括`0`），比如`[1,0,2]->[1,1,2]`<br/>
        * 2.前`i`个数`0`的数量,`[1,0,2]->[0,1,1]`<br/>
#### 总结
![18](https://img.vim-cn.com/55/31513f5c1babcedaecae5fa16ea83bad5219e9.png)<br/>

### 2.2 栈
#### 2.2.1 [理论讲解]栈
* 定义
    * 操作受限制的线性表/数组
    * 只能从尾部插入或删除，后进先出
    * 汉诺塔
    * 单调栈<br/>
	![19](https://img.vim-cn.com/d4/e80a7b60dd6e5fed14b88bfb29d195d18d7d06.png)
* 操作
    * `push()`
    * `pop()`
    * `top()`
    * `size()/empty()`
    * 所有操作均$O(1)$时间复杂度<br/>
	![20](https://img.vim-cn.com/55/4ff2cbb1dacf8d3213e5acc1a13560f73eff00.png)
* 实现栈
    * 需要的操作：`push,pop,top,size`
    * `class mstack`
    * 成员：`mstack.size=0,mlist.a=[]`
    * 方法：
        * `push：``a`的`size`位置放入/插入一个元素
        * `pop:``size`减`1`
        * `top:`返回`a`的`size`相应位置元素
        * `size:`返回`size`	
#### 2.2.2  [面试题] （Leetcode 224）简单计算器
> 题目：计算表达是的值，表达式含有非负整数，`*`，`-`，和括号`（）`<br/>
> 例子：<br/>
> 输入：$1+3,3-(1+2)$<br/>
> 输出：$31$<br/>
* 边界条件
    * 表达式都是有效的，无边界条件
* 题目分析
    * 简化问题:
        * 去掉（）
        * 去掉多位数字
        * 去掉空格
        * 自制例子 $1+3-2$<br/>
		![21](https://img.vim-cn.com/ba/a22b56e68de614b836c218058ec7f8bbd4d4f8.png) 
		![22](https://img.vim-cn.com/cd/b6f388909d2a172f4d17612bb0022c6171cba5.png) 
		![23](https://img.vim-cn.com/cd/7ee168f49b4088726864c3e0cb4641104a24db.png) 
		![24](https://img.vim-cn.com/ee/4b5fc33070b50cd045d98c256e33bedc7f955d.png)
    * 优化解法：<br/>
	![25](https://img.vim-cn.com/49/b6f2544df4d51a2c2eb7fe17f5d2b5c889b4c1.png)
	![26](https://img.vim-cn.com/72/5780d232127b893adc498cf23eb1dcd0256041.png)
        * 为什么减号要让加号先计算，如果是$1*3*2$呢？
        * 符号优先级 $‘*’ == ‘-’ < ‘*’ == ‘/’$
	![27](https://img.vim-cn.com/54/9d543e1130d6f82e9d1ea4c7cebf0f95fc4f9a.png) ![28](https://img.vim-cn.com/02/9832ca60ec506ff67e5b82a3176d35eb856951.png) ![29](https://img.vim-cn.com/ef/88bc33fce1d4f43be91e0111d77bd479648745.png)<br/>
        * 所以符号栈是个单调栈
    * 复杂问题
        * 多位数字 `num.top()*10*current_num`
        * 括号`（）`左括号优先级最高，只有右括号可以抵消<br/>
	![30](https://img.vim-cn.com/01/eef0f31dd0312156313845628182c230e113ba.png)
	![31](https://img.vim-cn.com/3e/3fa7d19f2e1142a2ff29fa20f3af0f6b9f85c3.png)
	![32](https://img.vim-cn.com/da/676b462f8971671e9a0bc5745cbac95960a49f.png)
	![33](https://img.vim-cn.com/60/186c603b1e954702141f400d141bc51f8eda40.png)<br/>
* 解题思路：
    * 1.定义符号优先级 `')' < '-' == '*' < '('`
    * 2.同级别符号可以弹出，低级别可以弹出高级别（除了左括号）
    * 3.定义一个数字栈和一个符号栈
    * 4.按顺序分别入数字栈和符号栈，符号栈根据符号级别来决定操作顺序
        * 空格：忽略
        * 数字：注意处理多位数字
        * 字符：根据优先级决定操作顺序，对于左括号直接入栈就好，右括号的话，在碰到左括号之前所有的符号都要出栈，最后出栈左括号，最后如果符号栈不为空，将符号栈和数字栈都出栈，将剩下的数字进行计算 ，最后得出的结果就是最终的结果
* 思考题
    * 增加$*$和$/$，同理，重新定义符号优先级，$*$和$/$优先级比$*-$高
    * 增加单目运算符例如$'!'$,直接对数字栈顶计算
    * 增加多种括号${},[]$,各类括号独立计算
    * 增加字符串运算符例如$log$,$tan$,和多位数字同理
    * 增加负数，浮点数，和多位数字同理
    * 增加包围式运算符，例如$|x|$,和括号同理，可以当做有运算功能的括号
#### 2.2.3  [面试题]（Leetcode 456）132模式
> 题目：给定一个数组，问是否能找到三个下标$i < j < k$，满足$a[i]<a[k]<a[j]$<br/>
> 例子:<br/>
> 	输入：[3,1,4,2]<br/>
>	输出：True<br/>
![34](https://img.vim-cn.com/0a/6bd2c55871e95e4602d8004be75d25c700a808.png)
* 边界条件
    * 1.数组数量小于等于`2`，返回`False`
* 暴力解法
    * 1.三重循环枚举所有的三元组
    * 2.判断每个三元组是否满足要求
    * 3.时间复杂度$O(N^3)$<br/>
	![35](https://img.vim-cn.com/08/6cd9eb08b541177d6de8523909795da8730da4.png)
* 遍历解法
    * 思考：
      * 假定确定了最大数`3`
      * 左边数一定是最小的
      * 右边数需要介于`1`和`3`之间
      * 右边数是比3小的最大数<br/>
	![36](https://img.vim-cn.com/c6/8126ef80f160437d2eacfb66b87ff004636586.png)
      * 找`a[j]`右边比他小的最大数
        * 1）遍历，$O(N)$
        * 2）平衡树，$O()log(N)$
    * 解法：
        * 1.顺序遍历数组，记录每个位置之前的最小值，`m_min[i] = min(m_min[i-1],a[i])`
        * 2.逆序遍历数组，记录每个位置之后比其小的最大值，遍历/平衡树
        * 3.枚举所有数,可以直接得到其之前的最小值和之后的比其小的最大值
        * 4.判断是否满足要求
        * $O(N^2)$或$O(Nlog(N))$
* 单调栈解法
    * 思考：
        * 1.初始插入一样大小的最大最小区间<br/>
	![37](https://img.vim-cn.com/91/33e5b4a741064e574b8270f1877f0bfc9b6e37.png)
        * 2.碰到比最大值更大的数，更新最大值<br/>
	![38](https://img.vim-cn.com/32/468a42f82decd4766c8a5859d4697446de3b81.png)
        * 3.碰到区间内的数，返回`true` <br/>
	![39](https://img.vim-cn.com/f9/844c78d45f090303fc9907d60f83c79a69b55f.png)
        * 4.碰到比最小值更小的数，插入新区间<br/>
	![40](https://img.vim-cn.com/2b/9955786bee7f60207576e10a896da3ffda5e02.png)
        * 5.当前区间最大值大于前一区间，最小值小于前一区间，移除前一区间<br/>
	![41](https://img.vim-cn.com/bb/8810db18e3092b8b88cf095f23786e1d204cf8.png)<br/>
	![42](https://img.vim-cn.com/62/8be798388c60d6d5a99e90477b64fe9f01c8b9.png)
    * 解法：
        * 假定有栈`stack`，中间存储形如`[l,r]`的区间二元组。当前数为`x`.
		```python
			if stack == [] or x < stack.top().l:
				stack.push([x,x])
			else:
				cur_min = stack.top().l
				while stack != [] and x >= stack.top().r:
					stack.pop()
				if stack != [] and x > stack.top().l and x < stack.top().r:
					return ture
				stack.push([cur_min,x])
		```
* 思考题
    * 这里的栈是存的区间（两个数），如果只能存一个数如何处理？
    * 求所有的`132`模式的数量
#### 总结
![43](https://img.vim-cn.com/34/a96b7194532b04481a6e24c3791f04bbf73caf.png)

### 2.3 队列
#### 2.3.1 [理论讲解]队列
* 定义
    * 操作受限制的线性表/数组
    * 只能从尾部插入，头部删除，先进先出
    * 消息队列<br/>
	![44](https://img.vim-cn.com/cc/b010be82f377b5c001a8551fb651bce19d396b.png)
* 类型
    * 双端队列：两端均可插入或删除<br/>
	![45](https://img.vim-cn.com/4b/54b17fb4df0b63e0d5e028c7bb0c28fccac77a.png)
    * 单调队列：队列内元素大小单调<br/>
	![46](https://img.vim-cn.com/12/fa6b6c70e7d7dbf09448490c9f068e091ebd0d.png)
    * 优先队列（堆）：优先级高的元素先出队<br/>
	![47](https://img.vim-cn.com/2e/96b47951966727b87a55e8ec82b2abe443684b.png)
* 实现
    * 需要的操作：`push,pop,size,head/tail`,注意：这里的`pop`和`push`位置不一样
    * class mqueue
    * 成员：`mqueue.size=0,mqueue.a=[],mqueue.head=None,mqueue.tail=None`
* 操作
    * 如何实现mqueue.a?
    * 需要支持头部删除
    * 1）使用链表<br/>
	![48](https://img.vim-cn.com/ae/6d8aa560c2a6ece2777aa67a53cb60cb3e3835.png)
    * 2）使用循环数组<br/>
	![49](https://img.vim-cn.com/d0/665b0ec68713eacc4953ae0669a77594af6a55.png)
    * 双端队列
    	* 1）使用双端链表
        * 2）使用循环数组

#### 2.3.2[面试题]（Leetcode 225）队列实现栈
> 题目：用队列实现栈，实现`push,pop,top,empty`操作<br/>
> 解法：两个队列模拟一个栈<br/>
> 举例：<br/>
```python
		MyStack stack = mew MyStack();
		stack.push(1);
		stack.push(2);
		stack.top();  // returns 2
		stack.pop();  // returns 2
		stack.empty(); // returns false
```
![50](https://img.vim-cn.com/3f/11a84955dcf5445ff0df0c014604180c183868.png)<br/>
* 思考题
    * 用两个栈实现一个队列   
        * 将a栈的数据 导入到b栈 ，然后在出栈，实现一个队列，时间复杂度为$O(N)$;
    * 用一个数组实现两个栈   
        * 将两个栈的栈底设置在数组的头尾，一个栈从前往后插入一个栈从后往前插入；
#### 2.3.3 [面试题]（Leetcode 239）动窗口最大值
> 题目：给定一个一维数组，用一个大小为`k`的数组在上面滑动，返回窗口中的最大值。<br/>
> 例子：<br/>
> 输入：$nums = [1,3,-1,-3,5,3,6,7], k = 3$<br/>
> 输出：$[3.3.5.5.6.7]$<br/>

![51](https://img.vim-cn.com/3d/f4e4e0ea3c39681e869e4cdd000953c632a48e.png)<br/>
* 边界条件
    * 题目保证 $1 <= k <= len(nums)$
* 暴力解法
    * 二重循环遍历
        * 1.遍历所有区间开始位置`x`,`[0,len(nums)-k)`<br/>
	![52](https://img.vim-cn.com/bb/109eb8f7e164e9bd3009abb79fff527a2f50c0.png)
        * 2.遍历所有`[x,x=k)`位置，得到最大值<br/>
	![53](https://img.vim-cn.com/17/093d95a7e3723c0d01973463bdb4460232c785.png)
        * 时间复杂度为$O(N*K)$<br/>
* $O(NlogN)$解法
    * 二重循环遍历
        * 1.遍历所有区间开始位置`x`,`[0,len(nums)-k)`
    	* 2.用一个优先队列（最大堆）存储窗口中的数，每次窗口挪动一格，从队列中删除出窗口的数，插入新的窗口的数
    * 时间复杂度$O(N*log(K))$
* $O(N)$解法
* 思考问题性质
    * 如果窗口中存在数`a`，`b`，`a`在`b`之前且`a<=b`,那么`a`不可能为最大值<br/>
	![54](https://img.vim-cn.com/00/45dc8673c07cb3a1dbd967aa9a758fd00c3e6e.png)
    * 窗口中的数单调递减！<br/>
	![55](https://img.vim-cn.com/19/bfa98960a824d2174be90aff11f6ee315f783a.png)
* 维护“窗口”中的数
    * 1.窗口中现有的第一个数即窗口最大值<br/>
    * 2.窗口前面能删除<br/>
    * 3.窗口后面能插入<br/>
    * 4.窗口后面能删除<br/>
    * 5.窗口存放（值，时间戳）的二元组，下标为`i`的数shijian戳为`i*k`,表示下标为`i*k`的数进来的时候，下标为`i`的数需要出去。<br/>
    * 双端队列能满足“窗口”所有操作需求！<br/>

* 解法思路
    * 1.新建一个存储（值，时间戳）的双端队列
    * 2.顺序遍历数组
    * 3.如果队列不为空，检查队首元素时间戳，应当出队则出队。
    * 4.如果队列不为空，若当前待$插入数>=队尾数$，队尾出队，直到不满足条件或队列为空。
    * 5.插入待插入数和对应的时间戳
    * 6.检查当前是否应该产生结果，若应该则取队首元素作为当前结果<br/>
	![60](https://ae01.alicdn.com/kf/H66e5542027be43aa809f3ac95296d6765.png)
* 思考题
    * 当前每一轮候选框的首和尾都是往后移动一个距离，如果第`i`轮首尾分别向后移动`a[i]`和`b[i]`的距离，每一轮的`max`是多少？
    * 求窗口中的数的方差
    * 求窗口中数的中位差
#### 总结
![61](https://ae01.alicdn.com/kf/Hc8693c5ab95b4b869d166f7215e2e09et.png)
### 2.4 链表
* [理论讲解]链表
* [面试题]反转链表
* [面试题]环形链表II
#### 总结
![70](https://ae01.alicdn.com/kf/Hb5105431e483438bb8cdbc2e8ee5568cj.png)
### &emsp;树
* [理论讲解]树
* [面试题]从前序与中序遍历序列构造二叉树
* [面试题]二叉树的最近公共祖先
#### 总结
![80](https://ae01.alicdn.com/kf/Hd396da058174480fba5157c759372cecM.png)
### &emsp;堆
* [理论讲解]堆
* [面试题]找出数据流的中位数
* [面试题]合并K个排序链表
#### 总结
![90](https://ae01.alicdn.com/kf/H7cb41bc330554ddfaade51757a6777b1Z.png)
### &emsp;二叉搜索树
* [理论讲解]二叉搜索树
* [面试题]二叉搜索树中的插入操作
* [面试题]二叉搜索树中第K小的元素
#### 总结
![100](https://ae01.alicdn.com/kf/H9d7634ed55fa4bccb30084b7b65f4d9e0.png)
### &emsp;图
* [理论讲解]图
* [面试题]找到小镇的法官
#### 总结
![110](https://ae01.alicdn.com/kf/H4bd4b7ef467e46eaa02f9df18767b984c.png)
### &emsp;优化你的缓存使用——LRU Cache
#### [实战演练]LRU-Cache
##### 1. 问题背景
> 我们在栈的章节学习了如何实现一个简单的计算器，我们考虑这样一种场景：我们需要实现一个计算器的类，这个类要对于输入的字符串计算式(我们假设合法)返回结果。因为计算器的实现不是本lab的主题，所以我们用python中的eval函数代替。
* 定义我们的计算器
```python
    #定义我们的“计算器”
    class calculator:
        def __init__(self):
            pass
        def calc(self,s):
            assert type(s) == str,'input must be string! Got '+str(type(s))
            try:
                return eval(s)
            except:
                print('input error! ',s)
```
* 测试一下
```python
    calc = calculator()
    print(calc.calc('1+3-2'))
    print(calc.calc('10*3'))
    print(calc.calc('123+(3*4)/2'))
```
    2 
    30 
    129.0
 > 我们的计算器能够正常工作，我们稍微复杂化一下场景，我们把这个计算器做成一个服务，不停地有请求来得到字符串的值。此外，这些请求有可能有很多是一模一样的。对于同样的字符串我们重复计算显然是无意义的。  
* 考虑一个极端例子，我们同一个字符串计算1000次，需要消耗799ms的时间
```python
    %%time
    s = '1+'*1000+'1'
    for i in range(1000):
        calc.calc(s)
```
Wall time: 799ms
* 显然，我们可以将已经有的结果缓存下来，每次字符串来了我们先查询缓存，如果有则返回。
* 特别的，字符串比较也是耗时的工作，我们可以将字符串先进行加密，变成hash值。
```python
    import hashlib
#利用hashlib来得到字符串的md5值
    def get_hashcode(s):
        md5 = hashlib.md5()
        md5.update(s.encode())
        return md5.hexdigest()
#测试一下
    et_hashcode('1+1')
```
'd96e018f51ea61e5ff2f9c349c5da67d'
* 然后我们为我们的计算器添加缓存
```python
    #带缓存的计算器
    class cache_calculator:
        def __init__(self):
            #定义缓存
            self.cache = {}
            pass
        def calc(self,s):
            assert type(s) == str,'input must be string! Got '+str(type(s))
            #计算hash值
            hashcode =  get_hashcode(s)
            if hashcode in self.cache: return self.cache[hashcode]
        
            try:
                res = eval(s)
                #更新hash值
                self.cache[hashcode] = res
                return res
            except:
                print('input error! ',s)
```
* 我们再来测试一下刚才的例子,可以看到，现在只要8ms了！
```python
    %%time
    calc = cache_calculator()
    s = '1+'*1000+'1'
    for i in range(1000):
        calc.calc(s)
```
Wall time: 7.98 ms
> 再来继续思考问题，如果输入的算式很多呢？特别是在现在的大数据时代，动辄就是上亿的访问。而我们的缓存不可能是无限大小的，因此，一旦我们的缓存满了，就需要有取舍。那么缓存满了怎么办？这就是我们LRU算法需要解决的问题。

> LRU也是面试中的超高频考题，其本身问题并不复杂，不过要求对各类数据结构都有良好的掌握和理解，也非常贴合实际问题。
##### 2. LRU Cache思想
> LRU全称是Least Recently Used，即最近最少使用。其核心思想是假如有一个数据很久都没有被访问过了，说明他未来继续被访问的概率也会很低。那么如果我们的缓存满了，这些低概率访问的缓存内容应该优先被清除。

> 而相反，如果某个数据一直频繁被访问，那么这个数据缓存能节省的时间也越大，应当被保留。

> 我们考虑从计算机角度来理解这个事情，我们为每个数据赋予一个优先级，那么如果某个数据一直被访问，他的优先级应当最高，否则如果一直未被访问，他的优先级应该最低，当缓存满了的时候，我们将优先级最低的数据清除出去，将空出来的空间存当前数据。

> 我们学过优先队列，我们假设我们有这么一个优先队列，所有的数都在优先队列里面，每个数都有一个优先级。注意，这里说的"数"实际上是<key,value>的键值对，随着key和value的不同，LRU也能适应各类场景。

> 我们现在来思考LRU cache的性质：<br/>
> 1.我们说过缓存是有限制的，我们假设容量上限为capacity。<br/>
> 2.通过我们的key，我们应该能够通过这个cache得到对应的value。即我们有方法get(key)，返回value,如果key不存在，我们返回-1。<br/>
> 3.如果我们访问了某个get(key)，我们应当将这个key的优先级提到最高，因为他刚刚访问过。<br/>
> 4.对应的，我们也需要有put(key,value)方法，用于将对应的键值对放进cache中。<br/>
> 5.对于put方法，我们put进去的key，也需要有目前最高的优先级，因为他也是“刚刚”访问过。<br/>
> 6.如果put时发现cache已经满了，我们需要删除当前优先级最低的键值对。

* 堆思想
> 我们在前面课程中提到过，我们可以用堆来实现优先队列结构。我们先来考虑如何用堆来实现LRU Cache。<br/>
> 1.首先我们有一个堆，堆中存储<key,priority>二元组，按priority大小来排序。<br/>
> 2.我们另外还有一个dict,dict中也存储<key,<value,priority>>二元组，用于指示key对应的二元组是什么。<br/>
> 3.为了方便计算优先级，我们记录全局当前最大的优先级max_priority。开始时为0。<br/>
> 4.对于get(key)方法：<br/>
    > A.我们从dict中查找key对应的二元组。dict查询O(1)。<br/>
    > B.如果没有找到，返回-1<br/>
    > C.我们从堆中删除这个二元组。堆删除O(log(n))。<br/>
    > D.我们修改二元组的priority为当前最大值加一，即max_priority+1，并将max_priority自身加一。O(1)。<br/>
    > E.将新的二元组插入到堆中。堆插入O(log(n))。<br/>
> 5.对于put(key,value)方法:<br/>
    > A.先调用get(key)，这样如果key对应的二元组已存在，就把他放在最靠前的位置。O(log(n))。<br/>
    > B.如果dict中已经存在key了，直接修改对应的value值并返回。O(1)。<br/>
    > C.如果dict中不存在key，建立二元组<key,max_priority+1>，并将max_priority自身加一。O(1)。<br/>
    > D.将二元组插入到堆中。O(log(n))。<br/>
    > E.建立二元组<key,<value,max_priority>>，将二元组插入到dict中。O(1)。<br/>
> 所以我们`put`和`get`方法时间复杂度均为`O(log(n))` 

* 链表思想
> 显然，我们的数据是根据优先级按顺序出cache的，这很像一个线性的过程，只是在这个线性过程中存在着某些要“插队”数据。所以我们在堆思想中用了堆这种非线性结构来解决这个问题。

> 我们思考一下是否能用线性结构来解决这个问题。假如说我们按照优先级把所有的数据排成一列，最前面的数据优先级最高，最后面的数据优先级最低。 先来思考一下我们的操作：

> 1.get：我们需要把某一个数据拿出来放在开头，其余数据保持顺序。<br/>
> 2.put：我们需要把一个新数据放在开头，如果长度超限我们需要移除末尾元素。<br/>
> 那么显然对于get，我们把某一个数据从列中拿出来并且放在开头的操作，链表是非常合适的。从链表中插入和删除节点复杂度均为O(1)。

> 那么我们考虑用链表来维护这个cache数据结构，来细化一下所需要的操作：

> 1.对于get(key):<br/>
    > A.我们需要知道key在链表中是否存在以及具体位置。链表本身不支持随机查询，不过我们同样可以用dict来存储key对应的节点。<br/>
    > B.我们需要从链表中删除一个中间节点，并且保持链表顺序，所以这个中间节点需要同时知道其前驱和后继，这也说明了这个链表需要是一个双向链表。<br/>
    > C.我们还需要将节点插入到链表头部，所以我们需要知道头部的位置，也即记录头指针head。<br/>
> 2.对于put(key,value):<br/>
    > A.我们可以用类似之前的方法来判断链表中是否存在目标节点，如果存在则将其提前。<br/>
    > B.如果cache满了，我们需要删除最后一个节点，所以我们需要记录尾指针tail。<br/>
    > c.同样，如果cache没满。我们也需要在尾部插入节点。<br/>
> 接下来我们考虑动手实现一个LRU Cache 
##### 3. LRU Cache的实现
* 定义链表节点
```python
    #首先我们定义链表节点，我们的链表是一个双链表，所以有pre和next两个指针，同时，我们还需要存节点的key和value值
    class node:
        def __init__(self,value=0,key=0):
            #前一个指针
            self.pre = None
            #后一个指针
            self.next = None
            #value值
            self.value = value
            #key值
            self.key = key
```
* 定义LRU类
```python
    #我们接下来定义我们的LRU类，我们先看看需要哪些方法

    class LRUCache(object):
        #初始化方法，capacity是Cache的容量
        def __init__(self, capacity):
            pass

        #我们需要能够在开头插入节点
        def insert_at_head(self,node):
            pass
    
        #我们同样也需要能够删除最后一个节点
        def erase_at_tail(self):
            pass
    
        #核心的get方法
        def get(self, key):
            pass

        #核心的put方法
        def put(self, key, value):
            pass
```
* 初始化方法
```python
    #先来看我们的初始化部分，我们前面提到过，我们需要一个dict来存储key和node的对应关系，需要head和tail指针
    def __init__(self, capacity):
        #存储key和node对应关系的dict
        self.mp = {}
        #头尾指针
        self.tail = None
        self.head = None
        #我们同样定义最大的缓存容量，以及已用的存储容量
        self.capacity = capacity
        self.count = 0
```
* 在开头插入一个节点
```python
    def insert_at_head(self,node):
        if self.count == 0:
            #先考虑边界条件，如果count=0，当前节点就是唯一节点，当然是头结点和尾节点了
            self.head = node
            self.tail = node
        else:
            #否则我们先找到头结点，把当前节点链在头结点前面
            node.next = self.head
            self.head.pre = node
            #注意我们需要更新现在的头结点
            self.head = node
        #插入节点了count当然加一，并且把key和node放在我们的dict中
        self.count += 1
        self.mp[node.key] = node
```
* 在尾部删除一个节点
```python
    def erase_at_tail(self):
        #如果当前没有节点当然也不存在删除最后一个节点的事情了
        if self.count == 0: return 
        
        #取出当前尾部节点
        n_node = self.tail
        if self.count == 1:
            #如果当前只有一个节点，那么删除完就全空了
            self.head = None
            self.tail = None
        else:
            #否则我们把tail节点指向当前节点的前一个节点，并断开连接
            self.tail = n_node.pre
            self.tail.next = None
            
        #最后我们从map中删除当前节点
        n_node.pre = None
        n_node.next = None
        n_key = n_node.key
        self.mp.pop(n_key)
        
        #当然count也要减一
        self.count -= 1    
```
* get方法
```python
     def get(self, key):
        #首先考虑边界，如果key不在dict中，我们直接返回-1
        if not key in self.mp: return -1
        
        #取出key所对应的节点
        n_node = self.mp[key]
        
        #第一种情况，如果这个节点就是头结点了，也不存在将其挪到开头的事情了，我们直接返回value
        if n_node == self.head: return n_node.value
        
        #对于其他情况，我们需要将其从链表中删除，并挪到开头，我们先考虑删除。
        
        #我们先取出其前一个和后一个节点
        pre_node = n_node.pre
        next_node = n_node.next
        
        if n_node == self.tail:
            #如果这个节点是尾部节点，直接调用方法删除尾部节点。
            self.erase_at_tail()
        else:
            #否则我们删除这个节点
            
            #1.先将其前后节点连起来
            pre_node.next = next_node
            next_node.pre = pre_node
            
            #2.删除这个节点
            n_node.pre = None
            n_node.next = None
            n_key = n_node.key
            self.mp.pop(n_key)
            self.count -= 1
        
        #最后，我们将这个节点插入到开头
        self.insert_at_head(n_node)
        
        return n_node.value
```
* put方法
```python
    def put(self, key, value):
        #首先我们调用get方法，如果未返回-1，说明其已经在map中有了。
        #由于我们调用get以后会把这个节点挪到开头，所以这种情况下我们直接修改头结点的值就可以了。
        if self.get(key) != -1:
            self.head.value = value
            return
        #如果容量满了，我们先删除最后一个节点
        if self.count == self.capacity:
            self.erase_at_tail()
        
        #最后我们定义一个新节点，把新节点插入到开头
        n_node = node(value,key)
        self.insert_at_head(n_node)
```
* 代码全貌，你可以尝试不依赖注释看懂每一个部分的内容。
```python
class LRUCache(object):
    def __init__(self, capacity):
        self.mp = {}
        self.tail = None
        self.head = None
        self.capacity = capacity
        self.count = 0

    def insert_at_head(self,node):
        if self.count == 0:
            self.head = node
            self.tail = node
        else:
            node.next = self.head
            self.head.pre = node
            self.head = node
        self.count += 1
        self.mp[node.key] = node
    
    def erase_at_tail(self):
        if self.count == 0: return 
        n_node = self.tail
        if self.count == 1:
            self.head = None
            self.tail = None
        else:
            self.tail = n_node.pre
            self.tail.next = None
            
        n_node.pre = None
        n_node.next = None
        n_key = n_node.key
        self.mp.pop(n_key)
        
        self.count -= 1
            
    def get(self, key):
        if not key in self.mp: return -1
        
        n_node = self.mp[key]
        if n_node == self.head: return n_node.value
        
        pre_node = n_node.pre
        next_node = n_node.next
        
        if n_node == self.tail:
            self.erase_at_tail()
        else:
            pre_node.next = next_node
            next_node.pre = pre_node
            n_node.pre = None
            n_node.next = None
            n_key = n_node.key
            self.mp.pop(n_key)
            self.count -= 1
        
        
        self.insert_at_head(n_node)
        
        return n_node.value

    def put(self, key, value):
        if self.get(key) != -1:
            self.head.value = value
            return
        
        if self.count == self.capacity:
            self.erase_at_tail()
        
        
        n_node = node(value,key)
        self.insert_at_head(n_node)
```
##### 4.使用LRU Cache
> 我们现在考虑把LRU用在我们的计算器中。
```python
    #先定义最大缓存
    max_cache_size = 10

    #LRU缓存的计算器
    class LRU_calculator:
        def __init__(self):
            #定义缓存
            self.cache = LRUCache(max_cache_size)
            pass
        def calc(self,s):
            assert type(s) == str,'input must be string! Got '+str(type(s))
            #计算hash值
            hashcode =  get_hashcode(s)
        
            #尝试从LRU Cache中取值
            res = self.cache.get(hashcode)
            if res != -1: return res
        
            try:
                res = eval(s)
                #更新LRU
                self.cache.put(hashcode,res)
                return res
            except:
                print('input error! ',s)
```
> 可以看到，修改非常的简单。且同样只需要9ms，当然这只是一个重复的例子，并没有完全发挥LRU的作用，你可以尝试用更多的例子来进行测试。
```python
    %%time
    calc = LRU_calculator()
    s = '1+'*1000+'1'
    for i in range(1000):
        calc.calc(s)
```
> Wall time: 8.98 ms
##### 5.总结
> 我们介绍了LRU Cache的实现思路，LRU Cache很好地缓解了了当缓存容量有限时的效率问题，其实现也非常明了和简洁。实际上在工业界，LRU也是非常常用的策略，这也是其作为高频面试题的原因之一。掌握LRU也能很好地帮助我们理解计算机的缓存机制，优化我们的代码效率。

> 和其他部分一样,我们同样留一些小思考：

> LRU Cache各个操作的时间复杂度是多少？<br/>
> 如果我们不同的key数量非常有限，我们还需要使用LRU么？应该如何优化算法？
## 3.算法篇
### &emsp;排序和查找
* [理论讲解]排序和查找
* [面试题]寻找旋转排序数组中的最小值
* [面试题]数组中的第K个最大元素
#### 总结
![120](https://ae01.alicdn.com/kf/H4e8ba89f340c4cccbe6cf5157ff26993U.png)
### &emsp;搜索
* [理论讲解]搜索
* [面试题]岛屿的个数
#### 总结
![130](https://ae01.alicdn.com/kf/Hbe3632fd3a504c498f2c7cd515a7711cE.png)
### &emsp;动态规划
* [理论讲解]动态规划
* [面试题]编辑距离
* [面试题]零钱兑换
#### 总结
![140](https://ae01.alicdn.com/kf/Hc7613321d8c74723b2d793d9d383d557b.png)
### [实战演练]背包问题
#### 1. 问题背景
> 我们在出行的时候，一定遇到过这样的问题，想带的东西很多，但是无奈背包容量有限。那么在这种情况下我们需要对带的物品进行一些取舍，这就是背包问题的由来。
#### 2. 01背包问题
> 假设我们有n个物品，第i个物品大小为a[i]，有一个容量大小为m的背包，问最多能装走多重的物品？

> 举一个实际的例子： 背包大小容量为10，我们想尽量装满背包。

> 我们有以下物品：

物品|体积
-|-
可乐|4
薯片|6
自热火锅|9
> 方案1：优先放体积最大的，那么我们只能拿到一个自热火锅，使用的总体积为9。(这也说明了背包问题不能通过贪心解决)

> 方案2：同时拿可乐和薯片，我们可以把背包装满。
* 动态规划解法
> **假设我们只有一个物品可乐，我们知道体积为4。**<br/>
> 我们设一个数组dp[i][j]表示前i个物品，放满容量为j的空间是否可行。那么首先dp[0][0] = 0，因为我们用0个物品总是可以放满0的空间，而对于dp[1]，我们有:

> | | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | | - | - | - | - | - | - | - | - | - | - | - | - | | dp[1] | True | False | False | False | True | False | False | False | False | False | False|

> dp[1][0]为True，是因为我们可以不取这个物品，这样我们的体积依旧为0。dp[1][4]为True，因为我们可以取这个物品，这样我们的背包里体积就用了4了。

> **我们再添加一个薯片进去，薯片体积为6**<br/>
> 我们现在是有两个物品了，对应的，dp[2]为：

> | | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | | - | - | - | - | - | - | - | - | - | - | - | - | | dp[1] | True | False | False | False | True | False | False | False | False | False | False| | dp[2] | True | False | False | False | True | False | True | False | False | False | True|

> 可以看到，相较于dp[1]，在dp[2]中，dp[2][6]和dp[2][10]也为True。也即分别对应取或者不取第二个物品的情况。

> 所以我们有我们的推断过程： 如果dp[i][j]=True，即前i个物品通过取舍有办法放满容量为j的空间，那么对于第i+1个物品,我们可以知道：

1. $𝑑𝑝[𝑖+1][𝑗+𝑎[𝑖+1]]=𝑇𝑟𝑢𝑒$
 
> 我们在前面的基础上，再拿一个体积为a[i+1]物品，即可使前i+1个物品占满容量为j+a[i+1]的空间。

2. $𝑑𝑝[𝑖+1][𝑗]=𝑇𝑟𝑢𝑒$
 
> 前i个物品可以有办法凑到j的空间，那么前i+1个物品肯定有办法，即直接采用前面的策略，我们不拿第i+1个物品就是了。<br/>

* **实现我们的动态规划解法**
  ```python
    #输入物品的重量,物品个数和背包大小
    a = [4,6,9]
    n = len(a)
    m = 10

    #定义动态规划数组
    import numpy as np
    dp = np.zeros((n+1,m+1),dtype=np.bool)
    #初始化
    dp[0][0] = True

    dp
  ```
  ```
    array([[ True, False, False, False, False, False, False, False, False,False, False],[False, False, False, False, False, False, False, False, False,False, False],[False, False, False, False, False, False, False, False, False,False, False],[False, False, False, False, False, False, False, False, False,False, False]])
  ```
  ```python
    for i in range(1,n+1): #枚举物品
        for j in range(m+1):
            dp[i][j] = False
            #如果要让dp[i][j]为true，则dp[i-1][j]和dp[i-1][j-a[i-1]]必然有一个为true
            dp[i][j] |= dp[i-1][j] #情况1
            if j >= a[i-1]:
                dp[i][j] |= dp[i-1][j-a[i-1]] #情况2
    dp
  ```
  ```
    array([[ True, False, False, False, False, False, False, False, False,False, False],[ True, False, False, False,  True, False, False, False, False,False, False],[ True, False, False, False,  True, False,  True, False, False,False,  True],[ True, False, False, False,  True, False,  True, False, False,True,  True]])
  ```
  ```python
    #最终我们需要知道最多能装多重的物品
    ans = 0
    for j in range(m,-1,-1):
        if dp[n][j]: #如果前n个物品正好能装满容量为j的空间
            ans = j
            break
    ans
  ```  
  ```
    10
  ```
#### 3. 带权重的01背包
>  我们刚才只考虑了背包尽量装满，但是有时候我们的物品可能有不同的价值。<br/>
>我们将物品都赋予一定的价值：
    
物品|体积|价值
-|-|-
可乐|4|1
薯片|6|2
自热火锅|9|5
> 还是来看两个方案：<br/>
> 方案1：只拿一个自热火锅，虽然背包没装满，但是总价值是5<br/>
> 方案2：同时拿可乐和薯片，我们可以把背包装满，但是总价值只有3
* **我们需要修改一下DP的状态含义**
> 我们设一个数组dp[i][j]表示前i个物品，放满容量为j的空间是否可行的最大价值。那么首先dp[0][0] = 0，因为我们用0个物品总是可以放满0的空间，由于没有拿物品，所以价值为0。

> 我们也需要更新我们的状态转移方程： 对于dp[i][j]状态，即前i个物品通过取舍有办法放满容量为j的空间，那么这种状态有可能从两个状态转移而来

> 1. 我们拿了第i个物品，那么拿了第i个物品后体积为j，没拿第i个物品的时候体积肯定为j-a[i]，所以相邻状态为dp[i-1][j-a[i]]

> 2. 我们没拿第i个物品，那么在前面i-1个物品我们需要有办法得到j的空间，所以相邻状态为dp[i-1][j]

* **实现我们的动态规划解法**
    ```python
        #输入物品的重量,物品个数，价值和背包大小
        a = [4,6,9]
        v = [1,2,5]
        n = len(a)
        m = 10

        #定义动态规划数组
        import numpy as np
        dp = np.zeros((n+1,m+1))

        #初始化
        dp.fill(-1) #赋值-1代表暂时不可行
        dp[0][0] = 0

        dp
    ```
    ```
    array([[ 0., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.],
           [-1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.],
           [-1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.],
           [-1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.]])
    ```
    ```python
        for i in range(1,n+1): #枚举物品
            for j in range(m+1):
                if dp[i-1][j] != -1:
                    dp[i][j] = max(dp[i][j], dp[i-1][j]) #不取第i个物品
                if j >= a[i-1] and dp[i-1][j-a[i-1]] != -1:
                    dp[i][j] = max(dp[i][j], dp[i-1][j-a[i-1]]+v[i-1]) #取第i个物品
        dp
    ```
    ```
    array([[ 0., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.],
           [ 0., -1., -1., -1.,  1., -1., -1., -1., -1., -1., -1.],
           [ 0., -1., -1., -1.,  1., -1.,  2., -1., -1., -1.,  3.],
           [ 0., -1., -1., -1.,  1., -1.,  2., -1., -1.,  5.,  3.]])
    ```
    ```python
        #最终我们需要知道最多能装多贵的物品
        ans = max(dp[n])
        ans
    ```
    ```
        5.0
    ```
#### 4. 路径记录
> 我们刚才只回答了如何得到最优的结果，但是并未回答最优的装配方案是什么
* **DP的同时记录最优路径**
> 我们前面提到，对于`dp[i][j]`状态，即前i个物品通过取舍有办法放满容量为j的空间，那么这种状态有可能从`dp[i-1][j-a[i]]`和`dp[i-1][j]`两个状态转移而来。

> 而实际上，如果从`dp[i-1][j-a[i]]`转移而来，则表示第i个物品会取，否则如果从`dp[i-1][j]`转移而来，则表示第i个物品不选。

> 因此我们在动态规划的时候，可以用一个额外的path数组记录每个值的转移路径，最终照着路径反向找到方案。
* **实现我们的动态规划解法**    
    ```python
        #输入物品的重量,物品个数，价值和背包大小
        a = [4,6,9]
        v = [1,2,5]
        n = len(a)
        m = 10

        #定义动态规划数组
        import numpy as np
        dp = np.zeros((n+1,m+1))

        #定义路径数组
        path = np.zeros((n+1,m+1))

        #初始化
        dp.fill(-1) #赋值-1代表暂时不可行
        dp[0][0] = 0

        dp
    ```
    ```
    array([[ 0., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.],
           [-1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.],
           [-1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.],
           [-1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.]])
    ```
    ```python
        for i in range(1,n+1): #枚举物品
            for j in range(m+1):
                if dp[i-1][j] != -1:
                    if dp[i][j] < dp[i-1][j]:
                        dp[i][j] = dp[i-1][j] # 不取第i个物品
                        path[i][j] = 1 #表示dp[i][j]由情况1转移而来
            if j >= a[i-1] and dp[i-1][j-a[i-1]] != -1:
                if dp[i][j] < dp[i-1][j-a[i-1]]+v[i-1]:
                    dp[i][j] = dp[i-1][j-a[i-1]]+v[i-1] #取第i个物品
                    path[i][j] = 2 #表示dp[i][j]由情况2转移而来
        dp
    ```
    ```
    array([[ 0., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.],
           [ 0., -1., -1., -1.,  1., -1., -1., -1., -1., -1., -1.],
           [ 0., -1., -1., -1.,  1., -1.,  2., -1., -1., -1.,  3.],
           [ 0., -1., -1., -1.,  1., -1.,  2., -1., -1.,  5.,  3.]])
    ```
    ```python
        #我们path已经记录好了转移路径
        path
    ```
    ``` 
    array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [1., 0., 0., 0., 2., 0., 0., 0., 0., 0., 0.],
           [1., 0., 0., 0., 1., 0., 2., 0., 0., 0., 2.],
           [1., 0., 0., 0., 1., 0., 1., 0., 0., 2., 1.]])
    ```
    ```python
        #最终我们需要知道最多能装多贵的物品
        j = np.argmax(dp[n])

        #反向回溯找路径
        i = n # 最终最优状态为dp[i][j]
        while ( i != 0 ):
            if path[i][j] == 1: # 第i个数不取
                pass
            else: # 第i个数取
                print('use %d'%(i-1))
                j -= a[i-1]
            i -= 1
    ```
    ```
        use 2
    ```
#### 5. 空间优化
> 我们前面的做法中，都使用到了dp这个二维数组，因此空间复杂度为O（n\*m）。但是实际上dp[i]的结果只和dp[i-1]有关，我们要计算dp[i]的时候，dp[i-1]之前的结果已经再也不会被用到了。因此，我们可以采用滚动数组技术来优化空间。
* **滚动数组**
> 我们减少我们的dp数组维度到dp[2][m]，现在来看看如何两个维度完成计算。

> 1. 最开始的时候，dp[0]和dp[1]和之前的计算过程一致，接下来，我们主要讲解dp[2]如何计算。
> 2. 按之前的方程，dp[2][j] = min(dp[1][j], dp[1][j-a[1]]+w[1]),但是我们现在数组没有第二维，那么我们可以把第0维重新利用起来，方程改为：dp[0][j] = min(dp[1][j], dp[1][j-a[1]]+w[1])，那么这里的dp[0][j]就是我们的dp[2][j]的值了。
> 3. 如果我们继续计算dp[3]，这次我们会把dp[3]的值记录在数组的第一维，这样直观来看，数组的两个维度在不停地滚动，因此这个数组也叫做滚动数组。

> 但是注意，因为我们现在只有两个维度的信息了，如果使用滚动数组优化了空间，我们就无法再记录方案了。
* **实现我们的动态规划解法**
    ```python
        #输入物品的重量,物品个数，价值和背包大小
        a = [4,6,9]
        v = [1,2,5]
        n = len(a)
        m = 10

        #定义动态规划数组
        import numpy as np
        dp = np.zeros((2,m+1))#现在第一维只需要2了

        #初始化
        dp.fill(-1) #赋值-1代表暂时不可行
        dp[0][0] = 0

        dp
    ```
    ```
    array([[ 0., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.],
           [-1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.]])
    ```
    ```python
        for i in range(1,n+1): #枚举物品
            k = i % 2 # k表示现在要把结果记录在哪一维
            for j in range(m+1):
                if dp[1-k][j] != -1: #因为现在只有两维了，我们把结果记录在第k维，那么用于计算的维度自然是1-k
                    dp[k][j] = max(dp[k][j], dp[1-k][j]) #不取第i个物品
                if j >= a[i-1] and dp[1-k][j-a[i-1]] != -1:
                    dp[k][j] = max(dp[k][j], dp[1-k][j-a[i-1]]+v[i-1]) #取第i个物品
        dp
    ```
    ```
    array([[ 0., -1., -1., -1.,  1., -1.,  2., -1., -1., -1.,  3.],
           [ 0., -1., -1., -1.,  1., -1.,  2., -1., -1.,  5.,  3.]])
    ```
    ```python
        #最终我们需要知道最多能装多贵的物品
        ans = max(dp[k])
        ans
    ```
    ```
        5.0
    ```
#### 6. 完全背包
> 我们之前的题目里，每个物品都是只有一个的，那么如果每个物品都有无限个，该如何解决？

> 假设我们现在有一个状态dp[i][j],现在考虑第i+1个物品。

> 1. 第i+1个物品不取，我们会得到dp[i+1][j]状态
> 2. 第i+1个物品取一个，我们会得到dp[i+1][j+a[i]]状态
> 3. 第i+1个物品取两个，我们会得到dp[i+1][j+2*a[i]]状态
> 4. 。。。

> 我们来思考一下dp[i+1][j]和dp[i+1][j+a[i]]，如果我们已经得到dp[i+1][j]的最优值了，那么再取一个i+1物品等价于在dp[i+1][j]的基础上再取一个物品。同理，dp[i+1][j+2*a[i]]也等价于在dp[i+1][j+a[i]]的基础上再取一个i+1物品。

> 所以，在完全背包问题中，dp[i][j]不光会从dp[i-1][j],dp[i-1][j-a[i]]来，也会从dp[i][j-a[i]]来。所以现在的方程为：
    
$𝑑𝑝[𝑖][𝑗]=𝑚𝑖𝑛(𝑑𝑝[𝑖−1][𝑗],𝑑𝑝[𝑖−1][𝑗−𝑎[𝑖]]+𝑤[𝑖],𝑑𝑝[𝑖][𝑗−𝑎[𝑖]]+𝑤[𝑖])$
 
* **实现我们的动态规划解法**
    ```python
    #输入物品的重量,物品个数，价值和背包大小
    a = [4,6,9]
    v = [1,2,5]
    n = len(a)
    m = 8

    #定义动态规划数组
    import numpy as np
    dp = np.zeros((n+1,m+1))

    #初始化
    dp.fill(-1) #赋值-1代表暂时不可行
    dp[0][0] = 0

    dp
    ```
    ```
    array([[ 0., -1., -1., -1., -1., -1., -1., -1., -1.],
           [-1., -1., -1., -1., -1., -1., -1., -1., -1.],
           [-1., -1., -1., -1., -1., -1., -1., -1., -1.],
           [-1., -1., -1., -1., -1., -1., -1., -1., -1.]]) 
    ```
    ```python
    for i in range(1,n+1): #枚举物品
        for j in range(m+1):
            if dp[i-1][j] != -1:
                dp[i][j] = max(dp[i][j], dp[i-1][j]) #不取第i个物品
            if j >= a[i-1] and dp[i-1][j-a[i-1]] != -1:
                dp[i][j] = max(dp[i][j], dp[i-1][j-a[i-1]]+v[i-1]) #取第i个物品
            if j >= a[i-1]:#完全背包的情况，还可以从dp[i][j-a[i-1]]转移过来
                dp[i][j] = max(dp[i][j],dp[i][j-a[i-1]])
        dp
    ```
    ```
    array([[ 0., -1., -1., -1., -1., -1., -1., -1., -1.],
           [ 0., -1., -1., -1.,  1., -1., -1., -1.,  1.],
           [ 0., -1., -1., -1.,  1., -1.,  2., -1.,  1.],
           [ 0., -1., -1., -1.,  1., -1.,  2., -1.,  1.]])
    ```
    ```python
    #最终我们需要知道最多能装多贵的物品
    ans = max(dp[n])
    ans 
    ```
    ```
    2.0    
    ```
#### 7. 分组背包
> 还有一种比较有意思的场景。例如我们带东西出门，有些东西我们有很多选择，例如我们要带一瓶水，我们可以带小瓶的农夫山泉，也可以带大瓶的脉动，但是我们不会带上所有的水，可能最后我们只会带一种。 那么抽象一下，我们有n组物品，每组中的物品也有体积和价值，但是我们只能拿一个。问能带走的最大价值。

> 其实本质上来说，分组背包和01背包并没有太大区别。可以这么来考虑，我们可以认为01背包是分组背包的一个特殊情况，每一组只有一个物品，那么对应于每一组的策略我们有不取和取物品1。但是分组背包，每一组的策略是不取，取物品1，取物品2。。。可以看到只是可选策略变多了，其他没有变化。

> 那么，我们假设a[i][j]代表第i组的第j个物品的体积，w[i][j]代表第i组的第j个物品的价值，我们现在的转移方程变为：

$𝑑𝑝[𝑖][𝑗]=𝑚𝑖𝑛(𝑑𝑝[𝑖−1][𝑗],min𝑘=0𝑙𝑒𝑛(𝑎[𝑖])[𝑑𝑝[𝑖−1][𝑗−𝑎[𝑖][𝑘]]+𝑤[𝑖][𝑘]])$
 
* **实现我们的动态规划解法**
    ```python
    #输入物品的重量,物品个数，价值和背包大小
    a = [[1,2],[3,2,1],[6,4,2]]
    v = [[3,1],[3,2,1],[3,4,2]]
    n = len(a)
    m = 8

    #定义动态规划数组
    import numpy as np
    dp = np.zeros((n+1,m+1))

    #初始化
    dp.fill(-1) #赋值-1代表暂时不可行
    dp[0][0] = 0

    dp
    ```
    ```
    array([[ 0., -1., -1., -1., -1., -1., -1., -1., -1.],
           [-1., -1., -1., -1., -1., -1., -1., -1., -1.],
           [-1., -1., -1., -1., -1., -1., -1., -1., -1.],
           [-1., -1., -1., -1., -1., -1., -1., -1., -1.]])
    ```
    ```python
    for i in range(1,n+1): #枚举组
        for j in range(m+1):
            if dp[i-1][j] != -1:
                dp[i][j] = max(dp[i][j], dp[i-1][j]) #不取第i个物品
            for k in range(len(a[i-1])):#枚举组内的物品
                if j >= a[i-1][k] and dp[i-1][j-a[i-1][k]] != -1:
                    dp[i][j] = max(dp[i][j], dp[i-1][j-a[i-1][k]]+v[i-1][k]) #取组内第k个物品
    dp
    ```
    ```
    array([[ 0., -1., -1., -1., -1., -1., -1., -1., -1.],
           [ 0.,  3.,  1., -1., -1., -1., -1., -1., -1.],
           [ 0.,  3.,  4.,  5.,  6.,  4., -1., -1., -1.],
           [ 0.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.]])    
    ```
    ```python
    #最终我们需要知道最多能装多贵的物品
    ans = max(dp[n])
    ans
    ```
    ```
    10.0
    ```
#### 8. 多重背包
> 虽然一个背包我们已经有很好的办法优化了，但是最土豪的方式还是多带一个背包。多重背包问题是，当我们有两个背包的时候，该如何规划我们的方案呢？

> 还是和之前一样，我们从我们的的策略出发来思考，那么对于一个物品，他有三种可能的方式：

> 1. 丢弃
> 2. 放进背包1
> 3. 放进背包2

> 我们之前的状态为dp[i][j]，表示前i个物品装满容量为j的背包的最大价值。那么我们可以把状态扩大一维，dp[i][j][k]代表前i个物品，第一个背包正好装了j，第二个背包正好装了k的最大价值。对应的，状态转移方程变为：

$𝑑𝑝[𝑖][𝑗][𝑘]=𝑚𝑖𝑛(𝑑𝑝[𝑖−1][𝑗][𝑘],𝑑𝑝[𝑖−1][𝑗−𝑎[𝑖]][𝑘]+𝑤[𝑖],𝑑𝑝[𝑖−1][𝑗][𝑘−𝑎[𝑖]]+𝑤[𝑖])$
 
* **实现我们的动态规划解法**
    ```python
    #输入物品的重量,物品个数，价值和背包大小
    a = [4,6,9]
    v = [1,2,5]
    n = len(a)
    m1 = 8
    m2 = 4
    #定义动态规划数组
    import numpy as np
    dp = np.zeros((n+1,m1+1,m2+1))

    #初始化
    dp.fill(-1) #赋值-1代表暂时不可行
    dp[0][0][0] = 0

    dp    
    ```
    ```
    array([[[ 0., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.]],

           [[-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.]],

           [[-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.]],

           [[-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.]]])    
    ```
    ```python
    for i in range(1,n+1): #枚举物品
        for j in range(m1+1):
            for k in range(m2+1):
                if dp[i-1][j][k] != -1:
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]) #不取第i个物品
                if j >= a[i-1] and dp[i-1][j-a[i-1]][k] != -1:
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-a[i-1]][k]+v[i-1]) #取第i个物品,放入背包1
                if k >= a[i-1] and dp[i-1][j][k-a[i-1]] != -1:
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-a[i-1]]+v[i-1]) #取第i个物品,放入背包2
    dp
    ```
    ```
    array([[[ 0., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.]],

           [[ 0., -1., -1., -1.,  1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [ 1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.]],

           [[ 0., -1., -1., -1.,  1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [ 1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [ 2., -1., -1., -1.,  3.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.]],

           [[ 0., -1., -1., -1.,  1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [ 1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.],
            [ 2., -1., -1., -1.,  3.],
            [-1., -1., -1., -1., -1.],
            [-1., -1., -1., -1., -1.]]])
    ```
    ```python
    #最终我们需要知道最多能装多贵的物品
    ans = np.max(dp[n])
    ans
    ```
    ```
    3.0
    ```
#### 5.总结
> 我们介绍了动态规划的一类基础问题——背包问题，并介绍了包括01背包，完全背包，多重背包等各种背包问题的变种。很多动态规划问题都有许多变种，其实大部分的思想都不会有太大改变，我们只需要重新思考当前情形下的转移方程就可以很好地解决了。 背包问题也是经典和高频的面试题目，大家需要熟悉相关的实现过程。
## &emsp;树算法
* [理论讲解]树算法
#### 总结
> 通过本课程，我们学习了最小生成树问题和kruskal算法，最小生成树问题在某些特定的线路优化问题上也具有一定的现实意义。关于最小生成树还有一个经典的算法叫做prim，大家可以自行学习比较。此外，我们还学习了一些树形动态规划的知识。树形动态规划本质上也是依据动态规划的思维逻辑，而且状态之间的关系在树结构上也更加明确了。

### &emsp;图算法
* [理论讲解]树算法
* [面试题]课程表
* [面试题]网络延迟时间
#### 总结
![150](https://ae01.alicdn.com/kf/Hc9a39ae808134c56b817246f47980143z.png)

## 4.面试经验篇
### &emsp;面试经验分享
* 面试破题技巧与白板实践


